## Аннотация

В данной курсовой работе рассматривается разработка и анализ распределенной базы данных, состоящей из двух шардов и общего провайдера идентификаторов. Система предназначена для эффективного хранения и обработки больших объемов данных, что особенно актуально в условиях современного информационного общества. Провайдер идентификаторов предоставляет уникальные идентификаторы пачками по 100000 штук за одно обращение, что значительно снижает нагрузку на систему и ускоряет процесс работы с данными.

Использование шардирования позволяет распределить данные по нескольким узлам, что обеспечивает высокую доступность и отказоустойчивость системы. Основной акцент делается на параллельной обработке SQL-запросов с использованием библиотеки MPI.NET на языке C#. Это позволяет эффективно использовать ресурсы многоядерных процессоров и значительно ускоряет выполнение операций с базой данных.

Работа включает в себя проектирование архитектуры системы, реализацию ключевых компонентов, а также тестирование производительности. Результаты показали, что применение параллельной обработки запросов может привести к значительному увеличению скорости выполнения операций, что делает систему подходящей для решения задач в условиях больших объемов данных.

В ходе исследования также рассматриваются сложности и ограничения, связанные с параллельной обработкой, такие как необходимость управления состоянием данных и синхронизации между потоками. Обсуждаются возможные направления для дальнейшего улучшения системы, включая оптимизацию алгоритмов обработки данных и расширение функциональности базы данных.

Таким образом, проведенное исследование имеет практическую ценность для разработки эффективных методов управления данными в распределенных системах и может быть полезно как для академического сообщества, так и для практикующих специалистов в области информационных технологий.

## Введение

С развитием информационных технологий и увеличением объемов данных, которые необходимо обрабатывать, возрастает потребность в эффективных методах управления и хранения этих данных. Одним из подходов к решению этой задачи является шардирование баз данных, которое позволяет распределять данные по нескольким узлам или серверам. Это особенно актуально для крупных приложений, работающих с большими объемами информации, где традиционные методы хранения могут не справляться с нагрузкой.

Ручное шардирование представляет собой процесс, при котором разработчик самостоятельно определяет, как данные будут распределены между различными шардированными узлами. Это может включать в себя выбор ключей шардирования и определение логики распределения данных. Преимущества ручного шардирования заключаются в том, что оно предоставляет разработчикам полный контроль над тем, как данные организованы и хранятся. Это позволяет оптимизировать производительность системы под конкретные сценарии использования, а также уменьшить задержки при доступе к данным.

Однако у ручного шардирования есть и недостатки. Во-первых, оно требует значительных усилий для настройки и поддержки. Разработчикам необходимо тщательно продумывать архитектуру системы, чтобы избежать проблем с балансировкой нагрузки и обеспечить высокую доступность данных. Во-вторых, ручное шардирование может усложнить выполнение определенных операций с данными, таких как объединение таблиц или использование внешних ключей (foreign keys). В связи с тем, что данные распределены по различным узлам, поддержание целостности данных становится более сложной задачей. Это приводит к необходимости реализовывать дополнительные механизмы для обеспечения согласованности данных.

Использование дополнительной базы данных в качестве источника идентификаторов (ID) является важным аспектом проектирования распределенных систем. В контексте разработки распределенной базы данных, которая состоит из нескольких шардов, организация эффективного механизма генерации и распределения уникальных идентификаторов становится критически важной для обеспечения целостности и согласованности данных.
    Преимущества использования дополнительной базы данных для ID
1. Централизованное управление идентификаторами: Дополнительная база данных может служить единым источником идентификаторов, что упрощает управление и предотвращает дублирование. Это особенно важно в распределенных системах, где разные узлы могут пытаться генерировать идентификаторы независимо друг от друга.
Увеличение производительности: Генерация идентификаторов пакетами (например, по 100000 штук) позволяет значительно сократить количество обращений к базе данных. Это снижает нагрузку на систему и ускоряет процесс получения идентификаторов, что особенно актуально при высоких нагрузках.
2. Гибкость и масштабируемость: Использование отдельной базы данных для ID позволяет легко масштабировать систему. При необходимости можно добавить новые шардированные узлы или изменить логику генерации идентификаторов без изменения основной структуры базы данных.
3. Упрощение логики приложения: Централизованный провайдер идентификаторов может скрыть сложность генерации уникальных значений от остальной части приложения, позволяя разработчикам сосредоточиться на бизнес-логике.
    Недостатки использования дополнительной базы данных для ID
1. Точка отказа: Если база данных, отвечающая за генерацию идентификаторов, выходит из строя, это может привести к остановке всей системы. Поэтому необходимо обеспечить резервирование и отказоустойчивость данного компонента.
2. Проблемы с производительностью при высокой нагрузке: При очень больших объемах запросов на получение идентификаторов может возникнуть узкое место в производительности, если база данных не будет оптимизирована должным образом.
3. Сложность реализации: Необходимость в дополнительной базе данных требует дополнительных усилий на проектирование и реализацию системы, что может увеличить время разработки.

В данной работе используется **PostgreSQL** как основная система управления базами данных (СУБД). PostgreSQL — это мощная объектно-реляционная СУБД с открытым исходным кодом, известная своей надежностью и расширяемостью. Она поддерживает множество современных функций, таких как транзакции, сложные запросы и расширенные типы данных. Однако одной из особенностей PostgreSQL является то, что при ручном шардировании возникает необходимость отказаться от использования внешних ключей. Это связано с тем, что внешние ключи требуют наличия единой схемы для обеспечения ссылочной целостности данных, что невозможно при распределении данных по нескольким узлам.

Для решения задач параллельной обработки запросов в рамках данной работы используется библиотека **MPI.NET** (Message Passing Interface for .NET). MPI является стандартом для параллельного программирования и широко используется в высокопроизводительных вычислениях. MPI.NET предоставляет возможность разработчикам .NET использовать интерфейс MPI для создания параллельных приложений. Это позволяет эффективно распределять задачи между несколькими процессами и узлами сети, что значительно увеличивает производительность обработки данных.

MPI.NET поддерживает различные модели передачи сообщений и синхронизации между процессами, что делает его идеальным инструментом для реализации параллельных SQL-запросов к распределенной базе данных. Используя MPI.NET, разработчики могут создавать приложения, которые способны обрабатывать большие объемы данных одновременно на нескольких узлах системы.

Таким образом, данная работа направлена на исследование возможностей ручного шардирования баз данных с использованием PostgreSQL и параллельной обработки запросов через MPI.NET. Мы рассмотрим как преимущества, так и недостатки данного подхода, а также предложим решения для повышения производительности и надежности системы в условиях больших объемов данных.

## Разработка программного проекта
На проектном уровне предлагаемое решение поставленной задачи достигается следующим образом.

1. Пользователь запускает CLI приложения.
2. Приложение запускает процессоры MPI, количество процессоров равно количеству баз - шардов.
2. Каждый процессор инициализируется и подключается к своему шарду, а так же к базе поставщику идентификаторов.
3. Если инициализация происходит хорошо и подключения заработали, то процессоры запрашивают новую пачку индентификаторов, т.к. у нас не возможонсти гарантировано знать сколько идентификаторов предыдущей пачки осталось после отключения.
4. После инициализации процессоров контроль передаётся пользователю.
5. Пользователь находится в консоли и вводит команды, которые обрабатываются в бесконечном цикле.
6. Каждая команда считывается root-процессором и затем транслируется в остальные процессоры.
7. Команды индивидуально выполняются и результат передаётся в root-процессор.
8. Root-процессор выводит результат пользователю и ожидает следующей команды.



## Реализация программного проекта
Рассмотрим ключевые фрагменты кода на языке C#:

...
MPI.Environment.Run(ref args, comm =>
{
    Shard shard = new Shard(comm);

    while(true) {
        string? cmd = shard.ReadLine();

        if(cmd?.StartsWith("Exit") == true
                || cmd?.StartsWith("Quit") == true
                || cmd?.StartsWith("q") == true) {
            shard.WriteLine("Bye!");
            break;
        }

        if(cmd?.StartsWith("CountAll") == true) {
            int count = shard.Measured(() => (shard.CountAll()));
            shard.WriteLine("All users count: {0}", shard.CountAll());
            shard.Stat();
            continue;
        }

        if(cmd?.StartsWith("ReadAll") == true) {
            List<User> l = shard.Measured(() => shard.ReadAll());
            shard.WriteLine("All users:");
            if(comm.Rank == 0) {
                l.ForEach(f => shard.WriteLine(f.ToString()));
            }
            shard.Stat();
            continue;
        }

...


В данном фрагменте кода мы видим реализацию параллельного выполнения команд в распределенной базе данных с использованием библиотеки MPI.NET. Основная логика программы заключается в бесконечном цикле, который ожидает ввода команд от пользователя и выполняет соответствующие действия.

Инициализируется среду MPI и запускается код внутри анонимного метода, передавая объект comm, который представляет текущий коммуникатор. Коммуникатор используется для обмена сообщениями между процессами.

Создается экземпляр класса Shard, который отвечает за взаимодействие с базой данных и выполнение операций над данными. Этот класс инкапсулирует логику работы с шардированной базой данных.

Цикл while(true) позволяет программе постоянно ожидать ввода команд от пользователя. Каждая команда обрабатывается по своему.
Если введенная команда начинается с "Exit", "Quit" или "q", программа завершает свою работу, выводя прощальное сообщение.
При вводе команды "CountAll" программа вызывает метод CountAll() для подсчета всех пользователей в базе данных. Результат отображается пользователю, а также записываются статистические данные о выполнении операции.
Команда "ReadAll" инициирует чтение всех пользователей из базы данных. Результаты выводятся только для процесса с рангом 0 (обычно это главный процесс), что позволяет избежать дублирования информации при выводе на консоль.

Генерация новых пользователей происходит с помощью метода Generate класса Shard.

...
public void Generate(int n) {
    int excess = n % count;
    int part = n / count;
    if(comm.Rank == 0) part += excess;

    Console.WriteLine("Generating {0} users in {1} process.", part, comm.Rank);
    dao.Insert(dao.Generate(part));
}
...

Метод использует класс UserDao, который инкапсулирует работу с конкретной таблицей базы данных данных.
Так же мы видим, что количество сгенерированных юзеров высчитывается исходя из количество шардов и ранга процесса.

Класс Conn инкапсулирует активное подключение к БД и даёт удобный интерфейс для вызова SQL запросов.

...
public class Conn
{
    String connString;
    NpgsqlConnection conn;

    public Conn(int port, string db, string username)
    {
        connString = string.Format("Host=localhost; Port={0}; Database={1}; User Id={2}; Password=;", port, db, username);
        conn = new NpgsqlConnection(connString);
    }

    public List<T> Read<T>(string query, Func<DbDataReader, T> maker) {
        using NpgsqlCommand cmd = new NpgsqlCommand(query, conn);
        using DbDataReader reader = cmd.ExecuteReader();

        List<T> results = new List<T>();

        while(reader.Read()) {
            results.Add(maker(reader));
        }

        return results;
    }

    public int Execute(string query) {
        using NpgsqlCommand cmd = new NpgsqlCommand(query, conn);
        return cmd.ExecuteNonQuery();
    }

    public void Open() {
        conn.Open();
    }

    public void Close() {
        conn.Close();
    }
}
...

Класс IdProvider так использует класс Conn для подключения к базе данных и исполнения запросов.
Он запрашивает номер текущей пачки идентификаторов, которая служит множителем следующего запрошенного ID.
Такая система эффективна т.к. снижает нагрузку на базу ID требуя лишь одного запроса на 100000 записей.
Однако, мы не можем гааранитировать, на каком ID мы остановились до перезапуска БД, поэтому все запрошенные, но неиспользованные индентификаторы становятся невалидными при перезапуске сервиса.

...
private string createString = "CREATE TABLE IF NOT EXISTS id_provider (id BIGSERIAL PRIMARY KEY, shardnum integer);";

private string getBatchString = "INSERT INTO id_provider (shardnum) VALUES({0}) RETURNING id;";

private int batchSize = 100_000;
private int currentId = 0;
private int currentBatch = 0;
private int shard = 0;

private Conn conn;

public IdProvider(Conn conn, int shard) {
    this.conn = conn;
    this.shard = shard;

    EnsureTableCreated();
    UpdateBatch();
}

public int GetId() {
    int id = currentId++;
    if(currentId == batchSize) {
        UpdateBatch();
    }

    return id + (currentBatch * batchSize);
}

private void UpdateBatch() {
    currentBatch = conn.Read(string.Format(getBatchString, shard), (r => readInt(r, "id")))[0];
}

private void EnsureTableCreated() {
    conn.Execute(createString);
}
...

## Тестирование

Для проверки эффективности разбиения на потоки проведём сравнительный тест запустив программу на одном и двух процессорах.
При запуске на двух процессорах каждый будет подключен к своему инстансу PostgreSQL.

Результаты:

# Single
Generate 100000
Generating 100000 users...
Generating 100000 users in 0 process.
On shard 0 new batch requested: 2
Rank: 0, Runtime: 00:16.05

Generate 250000
Generating 250000 users...
Generating 250000 users in 0 process.
Rank: 0, Runtime: 00:33.18

Generate 500000
Generating 500000 users...
Generating 500000 users in 0 process.
Rank: 0, Runtime: 01:11.74

# Double
Generate 100000
Generating 100000 users...
Generating 50000 users in 0 process.
Generating 50000 users in 1 process.
Rank: 0, Runtime: 00:08.30
Rank: 1, Runtime: 00:08.28

Generate 250000
Generating 250000 users...
Generating 125000 users in 0 process.
Generating 125000 users in 1 process.
Rank: 1, Runtime: 00:21.52
Rank: 0, Runtime: 00:21.65

Generate 500000
Generating 500000 users...
Generating 250000 users in 0 process.
Generating 250000 users in 1 process.
Rank: 1, Runtime: 00:41.18
Rank: 0, Runtime: 00:41.19

## Заключение

Заключение
В ходе данной работы была разработана и протестирована распределенная база данных с использованием шардирования и параллельной обработки запросов с помощью библиотеки MPI.NET. Результаты тестирования показали, что применение параллельных вычислений на двух потоках обеспечило двукратное увеличение производительности по сравнению с последовательной обработкой. Это подтверждает эффективность использования многопоточности для обработки больших объемов данных, что является критически важным в современных информационных системах.
MPI.NET продемонстрировала отличные результаты в реализации параллельной обработки SQL-запросов, позволяя эффективно распределять задачи между несколькими процессами. Это не только ускоряет выполнение операций, но и повышает общую отзывчивость системы, что особенно важно при работе с высоконагруженными приложениями.
Шардирование базы данных, реализованное в проекте, предоставляет значительные преимущества при горизонтальном масштабировании. В условиях, когда количество запросов может изменяться десятками тысяч в секунду, шардирование позволяет равномерно распределять нагрузку между несколькими узлами, обеспечивая высокую доступность и отказоустойчивость системы. Это делает систему более устойчивой к сбоям и позволяет легко масштабировать ее по мере роста требований бизнеса.
Таким образом, проведенное исследование подтверждает целесообразность использования распределенных баз данных и параллельной обработки для решения задач, связанных с управлением большими объемами данных. Результаты работы могут быть полезны как для академического сообщества, так и для практикующих специалистов в области информационных технологий, стремящихся к повышению эффективности своих приложений.
